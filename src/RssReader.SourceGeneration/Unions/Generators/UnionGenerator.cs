namespace RssReader.SourceGeneration.Unions.Generators;

internal static class UnionGenerator
{
    public static void AddUnion(this SourceProductionContext context, StructInfo structInfo)
    {
        var structName = structInfo.Name;
        var fullStructName = structInfo.GetFullTypeName();

        var builder = new StringBuilder();

        builder.AppendLine(
            $$"""
            // <auto-generated/>
            
            #nullable enable
        
            """);

        if (!string.IsNullOrEmpty(structInfo.Namespace))
        {
            builder.AppendLine(
                $$"""
                namespace {{structInfo.Namespace}};

                """);
        }

        if (structInfo.GenerateJsonConverter)
        {
            if (structInfo.IsGeneric)
            {
                builder.AppendLine(
                    $$"""
                    [global::System.Text.Json.Serialization.JsonConverter(typeof(global::{{Constants.OutputNamespace}}.{{structInfo.GetJsonConverterFactoryName()}}))]
                    """);
            }
            else
            {
                builder.AppendLine(
                    $$"""
                    [global::System.Text.Json.Serialization.JsonConverter(typeof(global::{{Constants.OutputNamespace}}.{{structInfo.GetJsonConverterName()}}))]
                    """);
            }
        }

        builder.AppendLine(
            $$"""
            [global::System.Diagnostics.DebuggerDisplay("TypeIndex: {TypeIndex}, {{string.Join(", ", structInfo.Types.Select(t => $$"""T{{t.Index}}: {_t{{t.Index}}}"""))}}")]
            partial struct {{fullStructName}}
            {
            """);

        // Fields
        foreach (var t in structInfo.Types)
        {
            builder.AppendLine(
                $$"""
                    private readonly {{t.TypeName}}? _t{{t.Index}};
                """);
        }

        builder.AppendLine();

        builder.AppendLine(
            $$"""
                public byte TypeIndex { get; }

            """);

        // Constructors
        builder.AppendLine(
            $$"""
                public {{structName}}()
                {
                    throw new global::System.NotImplementedException("Default constructor is not implemented.");
                }

            """);

        foreach (var t in structInfo.Types)
        {
            builder.AppendLine(
                $$"""
                    public {{structName}}({{t.TypeName}} t{{t.Index}})
                    {
                        TypeIndex = {{t.Index}};
                        _t{{t.Index}} = t{{t.Index}};
                    }

                """);
        }

        // Implicit conversions
        foreach (var t in structInfo.Types)
        {
            builder.AppendLine(
                $$"""
                    public static implicit operator {{fullStructName}}({{t.TypeName}} t{{t.Index}}) => new {{fullStructName}}(t{{t.Index}});
                """);
        }

        builder.AppendLine();

        // Switch
        builder.AppendLine(
            $$"""
                public void Switch({{string.Join(", ", structInfo.Types.Select(t => $$"""global::System.Action<{{t.TypeName}}> t{{t.Index}}"""))}})
                {
                    switch (TypeIndex)
                    {
            """);

        foreach (var t in structInfo.Types)
        {
            builder.AppendLine(
                $"""
                            case {t.Index}:
                                t{t.Index}({t.GetTypeAccessor()});
                                break;
                """);
        }

        builder.AppendLine(
            $$"""
                        default:
                            throw new global::System.InvalidOperationException($"Invalid type index: {TypeIndex}");
                    }
                }

            """);

        builder.AppendLine(
            $$"""
                public global::System.Threading.Tasks.Task Switch({{string.Join(", ", structInfo.Types.Select(t => $$"""global::System.Func<{{t.TypeName}}, global::System.Threading.Tasks.Task> t{{t.Index}}"""))}})
                {
                    return TypeIndex switch
                    {
            """);

        foreach (var t in structInfo.Types)
        {
            builder.AppendLine(
                $$"""
                            {{t.Index}} => t{{t.Index}}({{t.GetTypeAccessor()}}),
                """);
        }

        builder.AppendLine(
            $$"""
                        _ => throw new global::System.InvalidOperationException($"Invalid type index: {TypeIndex}")
                    };
                }

            """);

        // Match
        builder.AppendLine(
            $$"""
                public TResult Match<TResult>({{string.Join(", ", structInfo.Types.Select(t => $$"""global::System.Func<{{t.TypeName}}, TResult> t{{t.Index}}"""))}})
                {
                    return TypeIndex switch
                    {
            """);

        foreach (var t in structInfo.Types)
        {
            builder.AppendLine(
                $$"""
                            {{t.Index}} => t{{t.Index}}({{t.GetTypeAccessor()}}),
                """);
        }

        builder.AppendLine(
            $$"""
                        _ => throw new global::System.InvalidOperationException($"Invalid type index: {TypeIndex}")
                    };
                }

            """);

        // TryGet
        foreach (var t in structInfo.Types)
        {
            builder.AppendLine(
                $$"""
                    public bool TryGetT{{t.Index}}(out {{t.TypeName}} value)
                    {
                        if (TypeIndex is {{t.Index}})
                        {
                            value = {{t.GetTypeAccessor()}};
                            return true;
                        }

                        value = default!;
                        return false;
                    }

                """);
        }

        // Accessors
        foreach (var t in structInfo.Types)
        {
            builder.AppendLine(
                $$"""
                    public {{t.TypeName}} T{{t.Index}} => TypeIndex == {{t.Index}} ? {{t.GetTypeAccessor()}} : throw new global::System.InvalidOperationException("Result is not T{{t.Index}}");
                """);
        }

        builder.AppendLine(
            $$"""
            }
            """);

        context.AddSource(
            $"{structInfo.Namespace}.{structInfo.GetNormalizedTypeName()}.g.cs",
            SourceText.From(builder.ToString(), Encoding.UTF8));
    }
}
